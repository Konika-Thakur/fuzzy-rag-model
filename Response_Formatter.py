#!/usr/bin/env python3
"""
Response Formatter module for presenting results to the user
"""

import logging
import re
from typing import Dict, List, Any

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ResponseFormatter:
    """
    Formats the final response for display to the user
    """
    
    def __init__(self, max_similar_features: int = 2):
        """
        Initialize the Response Formatter
        
        Args:
            max_similar_features: Maximum number of similar features to include per feature
        """
        self.max_similar_features = max_similar_features
    
    def format_response(
        self,
        original_query: str,
        corrected_query: str,
        identified_features: List[Dict],
        feature_details: Dict[str, Dict],
        similar_features: Dict[str, List[Dict]],
        llm_response: str
    ) -> Dict[str, Any]:
        """
        Format the complete response for presentation to the user
        
        Args:
            original_query: Original user query
            corrected_query: Corrected query with canonical feature names
            identified_features: List of identified features
            feature_details: Dictionary of feature details
            similar_features: Dictionary of similar features keyed by feature name
            llm_response: Explanation generated by the LLM
            
        Returns:
            Dictionary containing the formatted response
        """
        logger.info("Formatting response for display")
        
        # Extract key information from LLM response
        explanation = self._extract_explanation(llm_response)
        
        # Format similar features for display
        formatted_similar = {}
        for feature_name, similar_list in similar_features.items():
            formatted_similar[feature_name] = similar_list[:self.max_similar_features]
        
        # Extract feature-specific explanations
        feature_explanations = self._extract_feature_explanations(
            llm_response, 
            [f['name'] for f in identified_features]
        )
        
        # Construct final response
        response = {
            'original_query': original_query,
            'corrected_query': corrected_query,
            'identified_features': identified_features,
            'feature_explanations': feature_explanations,
            'similar_features': formatted_similar,
            'explanation': explanation,
            'full_response': llm_response
        }
        
        return response
    
    def _extract_explanation(self, llm_response: str) -> str:
        """
        Extract the core explanation from the LLM response
        
        Args:
            llm_response: Full LLM response text
            
        Returns:
            Extracted explanation
        """
        # Remove any system-like prefixes often generated by LLMs
        cleaned = re.sub(r'^(Sure!|I\'d be happy to help!|Here\'s an explanation:|Certainly!)\s*', '', llm_response)
        
        # Remove any signature-like suffixes
        cleaned = re.sub(r'\n(Is there anything else.*|Let me know if.*|Hope this helps.*|Please let me know.*)$', '', cleaned)
        
        return cleaned.strip()
    
    def _extract_feature_explanations(self, llm_response: str, feature_names: List[str]) -> Dict[str, str]:
        """
        Extract specific explanations for each feature from the LLM response
        
        Args:
            llm_response: Full LLM response text
            feature_names: List of feature names to extract explanations for
            
        Returns:
            Dictionary mapping feature names to their explanations
        """
        explanations = {}
        
        # Split into paragraphs
        paragraphs = llm_response.split('\n\n')
        
        for feature in feature_names:
            # Look for paragraphs that mention this feature
            for paragraph in paragraphs:
                # Check if this paragraph is about this feature
                if feature in paragraph:
                    # Clean up the paragraph
                    explanation = paragraph.strip()
                    explanation = re.sub(r'^- ', '', explanation)
                    
                    # Store the explanation
                    explanations[feature] = explanation
                    break
        
        # If we couldn't find specific paragraphs for some features, assign generic ones
        for feature in feature_names:
            if feature not in explanations:
                explanation = f"A {feature} is a valuable feature that enhances the product's functionality and user experience."
                explanations[feature] = explanation
        
        return explanations
    
    def format_console_response(self, response: Dict[str, Any]) -> str:
        """
        Format the response for console display
        
        Args:
            response: The response dictionary
            
        Returns:
            Formatted string for console display
        """
        formatted = []
        
        # Add original and corrected queries
        formatted.append(f"Original Query: {response['original_query']}")
        formatted.append(f"Interpreted Query: {response['corrected_query']}")
        formatted.append("")
        
        # Add identified features
        formatted.append("Identified Features:")
        for feature in response['identified_features']:
            formatted.append(f"- {feature['name']} (confidence: {feature['confidence']:.2f})")
        formatted.append("")
        
        # Add explanation
        formatted.append("Explanation:")
        formatted.append(response['explanation'])
        formatted.append("")
        
        # Add similar features
        formatted.append("Similar Features You Might Like:")
        for feature_name, similar_list in response['similar_features'].items():
            for similar in similar_list:
                formatted.append(f"- {similar['name']} (similar to {feature_name})")
        
        return "\n".join(formatted)


if __name__ == "__main__":
    # Test code for the Response Formatter
    formatter = ResponseFormatter()
    
    # Example data
    original_query = "Looking for a chair with highbak and metl legs"
    corrected_query = "Looking for a chair with HighBack and Metal Legs"
    identified_features = [
        {"name": "HighBack", "confidence": 0.82},
        {"name": "Metal Legs", "confidence": 0.86}
    ]
    feature_details = {
        "HighBack": {
            "description": "Chair back that extends above shoulder height",
            "benefits": ["Better posture", "Reduced neck strain", "Head support"]
        },
        "Metal Legs": {
            "description": "Chair legs made of metal material",
            "benefits": ["Durability", "Modern look", "Stability"]
        }
    }
    similar_features = {
        "HighBack": [
            {"name": "Lumbar Support", "description": "Support for the lower back", "similarity": 0.85},
            {"name": "Ergonomic Design", "description": "Designed for body comfort", "similarity": 0.82}
        ],
        "Metal Legs": [
            {"name": "Industrial Design", "description": "Modern industrial aesthetic", "similarity": 0.88},
            {"name": "Aluminum Frame", "description": "Lightweight but strong", "similarity": 0.84}
        ]
    }
    llm_response = """
I understand you're looking for a chair with a HighBack and Metal Legs.

A chair with a HighBack provides excellent ergonomic support for your upper back, neck, and head, which is ideal for longer sitting sessions. This design helps maintain proper posture and reduces strain during extended use.

The Metal Legs offer several advantages: they provide excellent stability while maintaining a sleek, minimalist appearance. Typically made from steel, aluminum, or other alloys, these legs are stronger than wood alternatives and can support greater weight while appearing visually lighter.

You might also be interested in chairs with:
- Lumbar Support: This feature provides additional support for your lower back, further enhancing comfort and ergonomics.
- Industrial Design: This aesthetic complements metal legs perfectly and creates a contemporary look for modern spaces.

Please let me know if you have any other questions about these features or if you'd like recommendations for specific chairs that include these features.
    """
    
    # Format response
    response = formatter.format_response(
        original_query,
        corrected_query,
        identified_features,
        feature_details,
        similar_features,
        llm_response
    )
    
    # Print formatted response
    console_output = formatter.format_console_response(response)
    print(console_output)